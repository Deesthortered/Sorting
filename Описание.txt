1) Пузырьковая сортировка
Это примитивная сортировка, худшее и среднее время работы которой - квадрат. Принцип ее работы заключается в том, что каждый элемент поочереди поднимается выше
всех меньших за него элементов, будто сплывает как пузырек - отсюда и название. Использует два цикла - первый обрабатывает каждый элемент, второй сравнивает
текущий со всемы остальными. Не требует дополнительной памяти. Ничего сложно, нигде, кроме в целях обучения, не применяется.

2) Выборочная сортировка (сортировка выбором)
Тоже примитиваня сортировка с квадратичным средним и худшим временем работы. Принцып работы заключается в том, что во всем массиве происходит поиск минимального
элемента и вставляют его начало массива. В итоге с начала массив потихоньку становится упорядоченным и к концу работы все меньше и меньше эелементов приходится 
проверять. Не требует дополнительной памяти. Вроде бы особо нигде не применяется.

3) Сортировка вставками
Не такой уж примитивный, но простой алгоритм, который тоже имеет квадратичное время работы, но является эффективным для маленького количества элементов и потому
в таких случаях используется в стандартных библиотеках. Принцип ее работы заключается в следующем: обрабатываются все элементы от начала до конца и текущий элемент
сравнивается с предыдущими (которые уже отсортированы, потому что всё начинается с одного элемента, который уже отсортирован) и смещается влево до тех пор, пока не
станет на свое место, то есть пока подмассив и с предыдущих элементов не станет отсортирован. Не требует дополнительной памяти.

4) Сортировка Шелла
Является усоверешенствованным вариант сортировки вставками. Худшее время работы - квадрат, лучшее - n*log(n), среднее - зависит от выбраных шагов. Принцып работы 
заключается в том, что сначала сравниваюся элементы на определенном растоянии, которое с каждым проходом по массиву уменьшается. Обычно берут растояние в половину 
массива и с каждым проходом уменьшается вдвое. И в конце, когда растояние равно единице, сортировка превращается в сортировку вставками. Особенность этой сортировки 
в том, что в последнем проходе существенно уменьшается количество перестановок элементов и потому это может быть быстрее.

5) Шейкерная сортировка (сортировка перемешиванием)
Разновидность пузырьковой сортировки. Худшее и среднее время работы - квадрат. Принцип работы заключается в том, что кроме того, что большие элементы всплывают,
после каждого всплытыя, минимальный элемент тонет. В итоге имеем, что за каждый проход основного цикла один элемент сплывает, а второй - тонет и концу выполнения
алоритма массив отсортируется от концов к середине.

6) Сортировка слияниями
Непростая эффективный алгоритм со средним и худшим временем работы - n*log(n), в основе которого лежит декомпозиция ("разделяй и властвуй"). Массив данных делится
на два массива, которые в свою очередь деляться еще надвое и так до тех пор, пока не получим массивы с одним элементом, а потом проводим процедуру слияния - 
уже имея два отсортированых массива, выбираем меньший (больший) элемент из двух "начал" массивов до тех пор пока один из них не опустеет, потом докидываем остаток 
от другого. Несмотря на время работы, как правило работает дольше, чем быстрая сортировка.

7) Быстрая сортировка (сортировка Хоара)
Самый эффективный алгоритм сортировки в основе которого тоже есть декомпозиция и при этом прямой доступ к данным. Имеет квадратичный худшее время работы, но при 
этом среднее время работы - n*log(n) и на практике является быстрее остальных алгоритмов, у которых худшее время работы - n*log(n). Принцип его работы заключается
в следующем - сначала выбирается опорный элемент, абсолютно неважно какой - алгоритм в любом случае коректен (но это может повлиять на время работы на некоторых
данных) - в нашем случае будет выбран элемент посередине (это хоть как то амортизирует время работы на плохих данных, например, отсортированый в обратном порядке
массив). Далее создаем два итератора, которые будут указывать на начало и конец массива и в цикле они будут "сближаться" по пути переставляя элементы, которые 
больше (для первого итератора с начала) опорного или меньше (для второго итератора с конца). После этого проводим рекурсивно ту же операцию на двух половинах 
массива до теъ пор пока в подмассиве не будет один элемент. В итоге получим отсортированый массив, причем мы не создаем подмассивы в памяти (как в сортировке
слияниями), а используем ссылки на входной массив и ограничивающие итераторы. С этого следует, что алгоритм не требует дополнительной памяти и не тратит время
работы на резервирование памяти, что являются очевиднвми плюсами. Этот алгоритм используется во всех библиотеках и везде, где вообще что то сортируется.
Эффективен на больших объемах данных, но на (очень) маленьких сортировка вставками быстрее.


8) Блочная сортировка (черпаковая, корзинная, ведерная)
Очень интересный вид сортировки, который чем то напоминает цепочную хеш-таблицу. Принцип ее работы заключается в том, что мы каждый элемент сортируемого массива
помещаем в определенный блок памяти в зависимости от его значения. То есть мы создаем массив списков, размером такой же как и данный (это необязательно, его можно
регулировать) и циклом проходимся по данному массиву, помещая элементы во второй массив с индексом i = ([значение] * [кол-во элементов])/([макс. значение] + 1).
В случае коллизии элемент находит свое место как в сортировке вставками (учитывая, что как правило в подсписке маленькое кол-во элементов, то это эффективно). 
После заполнения второго массива, с него по-порядку считываются элементы (которые уже считай все отсортированы) и записываются в исходный массив.
Этот метод может быть быстрее быстрой сортировки, но на практике это далеко не всегда так и эта сортировка требует дополнительной линейной памяти, что делает
его менее привлекательным, чем быстрая сортировка.
ВНИМАНИЕ!!! В этом проекте эта сортировка реализована под числа. Если нужно сортировать другие данные, то нужно переделать принцип распределения элементов в новый
массив (то есть умножение убрать и поставить сво правило, возможно нужно изменить размер второго массива).

9) Сортировка подсчетом
Простой, но ограниченный алгоритм сортировки, который хоть и имеет линейное время работы, но целесообразно применять, только к целым числам (можно обобщить и для
дробных, но тогда при обобщении алгоритм часто становится нецелесообразным), которые имеют ограниченый диапазон значений. Принцип его работы таков: создаем массив
целых положительных чисел размером в диапазон возможных значений (максимум - минимум + 1) и проходим циклом по массиву и используем значение данного элемента, что
бы сразу получить индекс вторго массива и увеличиваем значение элемента второго массива на единицу. В итоге получим массив, в котором индекс - число - минимкм, 
а значение - количество. И с его помощью выводим индекс + минимум столько раз, сколько равно его значение. В итоге становится ясно почему он малоприменим, но
в некоторых случаях он очень хорошо подходит.
ВНИМАНИЕ!!! В этом проекте эта сортировка реализована под числа.

10) Позарядная сортировка
Интересный и непростой алгоритм сортировки с линейным временем работы, который предназначен для положительных целых чисел. Правда ним можно сортировать любе данные
по байтам, но это малоприменимо на практике. Принцип его работы заключается в том, что мы сортируем числа с младшего до старшего разряда, используя дополнительную 
линейную память + массив 10 чисел. Для этого предварительно узнаем число разрядов и с ним проходим в цикле, где подсчитываем сколько та или инная цифра встречается
на текущем разряде, далее с помощью этих данных располагаем числа новом массиве по порядку за определенным законом. В итоге получаем отсортированый массив.
ВНИМАНИЕ!!! В этом проекте эта сортировка реализована под числа.

11) Сортировка кучей (пирамидальная сортировка)
Сложный (относительно других) алгоритм сортировки любых данных (не только чисел) с гарантированым временем работы n*log(n) и не требует дополнительной памяти, 
что очен хорошо, но из-за высокой константы ступает сортировке Шелла на массивах до тысячи элементов и на практике медленнее, чем быстрая сортировка (даже учитывая 
ее деградацию). Всё же этот алгоритм активно применяется в ядре Linux. Принцип ее работы заключается в следующем: массив воспринимается как структура данных КУЧА
(или пирамида), предварительно востанновив в ней все свойства, и с нее извлекаются элементы (уже в отсортированом порядке, выполнив все действия для сохранения 
свойств кучи) пока куча не опустеет. В итоге получаем отсортированый массив.
ВНИМАНИЕ!!! Реализовать сортировку мне было впадлу, потому что она сложно реализуемая и структура данных КУЧА я уже создавал на другом репозитории и если нужно,
ее можно взять оттуда и, просто поместив в нее и извлекая из нее элементы можно получить отсортированый массив.

Это были все основные сортировки, которые я написал, что бы подготовится.